
Implement the Matcher.that(Matcher) / havingTrait(Matcher) / *** matching(Matcher) *** combinator
    Add an overload for Matcher.that((T) -> )

Draft matching algorithm and think on its plugability

Try to plug that into presto


=============================

    matching multiple patterns in one pass

    not(Matcher): Matcher<Boolean>

    Verify if static interface methods are as intended (can be invoked on containing interface only)
    FIXME make the Match returned by matcher different from a MatchResult, containing captures as well
        we'd like capture handling to be done by the framework, after all - and Match is produced by the user's code

    Optional matches, optional captures

    Create a test in a dfiferent package (e.g. 'example') to verify methods visibility

    Then, search for public methods not used in tests and test em all

    TEST EACH COMBINATOR
     -> for null input
     -> for class mismatch non-match

    take code completion for a drive, make it work seamlessly

    ? - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)

    massage types to eliminate casts in Property

    MAGICALLY GENERATE VALUES BASED ON MATCHERS

    HOW ABOUT RESOLVING NODES!?
    WHO HANDLES TRAVERSAL? THE MATCHER? THE MATCHER-RUNNING-PRATY?
    HOW DO THE MATCHERS MATCH GROUPS?
    HOW DO THE MATCHERS ITERATE THROUGH GROUPS TO FIND MATCHES?

     - matcher reevaluation for new trees using memoization (caching)
       - property matches thus have a special .having(propertyReference, matcher) syntax

    RECURSIVE MATCHERS
     - using a special capture?

    IDEAS / TODOS:
     - MATCHING LIST/COLLECTION PROPERTIES
        - add POC tests, create basic combinators

     - inject the evaluation strategy in order to execute the match? (a'la typeclasses)
     - define a library of matchers and properties and import it statically in a rule superclass
     - LATER provide default captures for properties

     - (?) match properties using 'dynamic' typing
       - have a match mode signaling errors
     - Property.$("string property name").available() for dynamic properties

     - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)

     Express co/contra-variance with casts in factory methods

     CONCEPT CANDIDATES:
     - Matcher<T> - matches values/evidence of type T. has an Optional<Capture<? super T>>
     - Match<T> - the match result, containing the matched value of type T and the captures (?)
     - Captures - a typesafe heterogenous map, keyed using Capture<T>
     - Capture<T> - a token used for naming matcher captures
     - PropertyResolver?
     - ResolutionStrategy?
     - EvaluationStrategy?

    DEBUGGABILITY
     - toStrings
     - sensible scopes in debugger

    match(Project.as(parent)
        .having(Project::source, Filter.as(filter)
            .having(Filter::condition, disjunction)))

    match(Project.as(parent)
        .having(TRANSITIVE_SOURCE.matching(Filter.as(filter)) //has resolutions handled for them, possibly is evaluated multiple times down the tree with subsequent resolutions
            .having($(FilterNode.class, FilterNode::condition).matching(disjunction))))

    (!) This means the PropertyMatcher must drive the match a bit

    //at least one level below
    match(Project.as(parent)
        .having(source, ANY
            .having(transitiveSource, Filter.as(filter)

    match(Join.as(join)
            .having(stupidCorrelations) //has to handle resolutions itself (?)
            .having(Join::build, TableScan.as(left).having(someCompoundProperty.as(evidence))) //has resolutions handled for them
            .having(Join::probe, Project.as(right))
    )


    match(Join.as(join)
            .having(Join::build, ANY.as(left))
            .having(Join::probe, sameAs(left)) //IDEALLY: sameAs covariant on matched nodes
    )


    withSource(child, Values).having(prunedInputs, prunableInputs)

    match(ts, TableScan)
        .having(name, property(TableScanNode::tableName, value) )
        .having(name, property(TableScanNode::tableName, extractor) )

    For now, `assuming` funcitons and - more importantly - class-based matchers do not match nulls.
    This also means any matcher constructing the `assuming` function won't ever get a null value to match against
    (which seems a sane default)
    This can be changed in future, at least in two ways:
     - add an .orNull() method to Matcher
     - make the `assuming` combinator pass-through nulls. If that happens, property matchers will have to start
       handling part of the resolution, or we'd have to use two `assuming` variants (null/non-null)...
    The more I think of it, the more I believe `.orNull()` is the only sensible change in this area.




DONE separate general purpose matching (hasChild, anyTree, etc) from the AST hierarchy by a different type
DONE allow capturing multiple properties -> possible by returning a POJO as match result
OBSOLETE - all the matchers match Object (even if there's sugar to narrow the type)
    an operator allowing for optional cast for matching purposes

NAH... Allow two DSL variants if it comes to static methods? With the '$'?

NAH - no nulls are the default, at least now
        .noNulls() modifier for closure matchers being easier:
        `match(Integer.class, x -> x > 0).noNulls()`

DONE Make the matchers extractors (allow extracting arbitrary values)
DONE Use invariant types everywhere for now.

OBSOLETE name captures using private enums (it can be enforced that the parameter is of enum type)
DONE even better, use Capture<T> fieldName = newCapture() to allow typesafe capture result referencing
