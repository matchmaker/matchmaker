
Draft matching algorithm and think on its plugability

Allow two DSL variants if it comes to static methods? With the '$'?


=============================

    FIXME make the Match returned by matcher different from a MatchResult, containing captures as well
        we'd like capture handling to be done by the framework, after all - and Match is produced by the user's code

    Try and see what happens to the code if we make Capture carry the captured value as well

    For now, `assuming` funcitons and - more importantly - class-based matchers do not match nulls.
    This also means any matcher constructing the `assuming` function won't ever get a null value to match against
    (which seems a sane default)
    This can be changed in future, at least in two ways:
     - add an .orNull() method to Matcher
     - make the `assuming` combinator pass-through nulls. If that happens, property matchers will have to start
       handling part of the resolution, or we'd have to use two `assuming` variants (null/non-null)...
    The more I think of it, the more I believe `.orNull()` is the only sensible change in this area.

    Optional matches, optional captures

    Create a test in a dfiferent package (e.g. 'example') to verify methods visibility

    Then, search for public methods not used in tests and test em all

    TEST EACH COMBINATOR
     -> for null input
     -> for class mismatch non-match

    3. make code complpetion work
    4.
     - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)


    .noNulls() modifier for closure matchers being easier:
        `match(Integer.class, x -> x > 0).noNulls()`

    massage types to elliminate casts in Property

    HOW ABOUT RESOLVING NODES!?
    WHO HANDLES TRAVERSAL? THE MATCHER? THE MATCHER-RUNNING-PRATY?
    HOW DO THE MATCHERS MATCH GROUPS?
    HOW DO THE MATCHERS ITERATE THROUGH GROUPS TO FIND MATCHES?

     - matcher reevaluation for new trees using memoization (caching)
       - property matches thus have a special .having(propertyReference, matcher) syntax


    FIXME PropertyMatchers must be handed current captures! (do they?)

    IDEAS / TODOS:
     - MATCHING LIST/COLLECTION PROPERTIES

     - OBSOLETE name captures using private enums (it can be enforced that the parameter is of enum type)
     - even better, use Capture<T> fieldName = newCapture() to allow typesafe capture result referencing
     - separate general purpose matching (hasChild, anyTree, etc) from the AST hierarchy by a different type
     - allow capturing multiple properties -> possible by returning a POJO as match result
     - an operator allowing for optional cast for matching purposes
     - inject the evaluation strategy in order to execute the match? (a'la typeclasses)
     - define a library of matchers and properties and import it statically in a rule superclass
     - LATER provide default captures for properties

     - (?) match properties using 'dynamic' typing
       - have a match mode signaling errors
     - Property.$("string property name").available() for dynamic properties

     - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)


     Express co/contra-variance with casts in factory methods

     CONCEPT CANDIDATES:
     - Matcher<T> - matches values/evidence of type T. has an Optional<Capture<? super T>>
     - Match<T> - the match result, containing the matched value of type T and the captures (?)
     - Captures - a typesafe heterogenous map, keyed using Capture<T>
     - Capture<T> - a token used for naming matcher captures
     - PropertyResolver?
     - ResolutionStrategy?
     - EvaluationStrategy?

    DEBUGGABILITY
     - toStrings
     - sensible scopes in debugger



    match(Project.as(parent)
        .having(Project::source, Filter.as(filter)
            .having(Filter::condition, disjunction)))

    match(Project.as(parent)
        .having(TRANSITIVE_SOURCE.matching(Filter.as(filter)) //has resolutions handled for them, possibly is evaluated multiple times down the tree with subsequent resolutions
            .having($(FilterNode.class, Filter::condition).matching(disjunction))))

    (!) This means the PropertyMatcher must drive the match a bit

    //at least one level below
    match(Project.as(parent)
        .having(source, ANY
            .having(transitiveSource, Filter.as(filter)

    match(Join.as(join)
            .having(stupidCorrelations) //has to handle resolutions itself (?)
            .having(Join::build, TableScan.as(left).having(someCompoundProperty.as(evidence))) //has resolutions handled for them
            .having(Join::probe, Project.as(right))
    )


    match(Join.as(join)
            .having(Join::build, ANY.as(left))
            .having(Join::probe, sameAs(left)) //IDEALLY: sameAs covariant on matched nodes
    )


    withSource(child, Values).having(prunedInputs, prunableInputs)

    match(ts, TableScan)
        .having(name, property(TableScanNode::tableName, value) )
        .having(name, property(TableScanNode::tableName, extractor) )

DONE Make the matchers extractors (allow extracting arbitrary values)
DONE Use invariant types everywhere for now.
