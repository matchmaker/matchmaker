
CAPTURES and NPEs:
    Fix NPEs when matching null values
    Replace the Optional with Match, containing the matched value and captures

Draft matching algorithm and think on its plugability


=============================

    TEST EACH COMBINATOR
     -> for null input
     -> for class mismatch non-match

    3. make code complpetion work
    4.
     - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)


    .noNulls() modifier for closure matchers being easier:
        `match(Integer.class, x -> x > 0).noNulls()`

    massage types to elliminate casts in Property

    HOW ABOUT RESOLVING NODES!?
    WHO HANDLES TRAVERSAL? THE MATCHER? THE MATCHER-RUNNING-PRATY?
    HOW DO THE MATCHERS MATCH GROUPS?
    HOW DO THE MATCHERS ITERATE THROUGH GROUPS TO FIND MATCHES?

     - matcher reevaluation for new trees using memoization (caching)
       - property matches thus have a special .having(propertyReference, matcher) syntax


    FIXME PropertyMatchers must be handed current captures! (do they?)

    IDEAS / TODOS:
     - MATCHING LIST/COLLECTION PROPERTIES

     - OBSOLETE name captures using private enums (it can be enforced that the parameter is of enum type)
     - even better, use Capture<T> fieldName = newCapture() to allow typesafe capture result referencing
     - separate general purpose matching (hasChild, anyTree, etc) from the AST hierarchy by a different type
     - allow capturing multiple properties -> possible by returning a POJO as match result
     - an operator allowing for optional cast for matching purposes
     - inject the evaluation strategy in order to execute the match? (a'la typeclasses)
     - define a library of matchers and properties and import it statically in a rule superclass
     - LATER provide default captures for properties

     - (?) match properties using 'dynamic' typing
       - have a match mode signaling errors
     - Property.$("string property name").available() for dynamic properties

     - shortcut:
        $(ProjectNode::getSource).matching(any()).as(capture)
        $(ProjectNode::getSource).as(capture)


     Express co/contra-variance with casts in factory methods

     CONCEPT CANDIDATES:
     - Matcher<T> - matches values/evidence of type T. has an Optional<Capture<? super T>>
     - Match<T> - the match result, containing the matched value of type T and the captures (?)
     - Captures - a typesafe heterogenous map, keyed using Capture<T>
     - Capture<T> - a token used for naming matcher captures
     - PropertyResolver?
     - ResolutionStrategy?
     - EvaluationStrategy?

    match(Project.as(parent)
        .having(Project::source, Filter.as(filter)
            .having(Filter::condition, disjunction)))

    match(Project.as(parent)
        .having(TRANSITIVE_SOURCE.matching(Filter.as(filter)) //has resolutions handled for them, possibly is evaluated multiple times down the tree with subsequent resolutions
            .having($(FilterNode.class, Filter::condition).matching(disjunction))))

    (!) This means the PropertyMatcher must drive the match a bit

    //at least one level below
    match(Project.as(parent)
        .having(source, ANY
            .having(transitiveSource, Filter.as(filter)

    match(Join.as(join)
            .having(stupidCorrelations) //has to handle resolutions itself (?)
            .having(Join::build, TableScan.as(left).having(someCompoundProperty.as(evidence))) //has resolutions handled for them
            .having(Join::probe, Project.as(right))
    )


    match(Join.as(join)
            .having(Join::build, ANY.as(left))
            .having(Join::probe, sameAs(left)) //IDEALLY: sameAs covariant on matched nodes
    )


    withSource(child, Values).having(prunedInputs, prunableInputs)

    match(ts, TableScan)
        .having(name, property(TableScanNode::tableName, value) )
        .having(name, property(TableScanNode::tableName, extractor) )

DONE Make the matchers extractors (allow extracting arbitrary values)
DONE Use invariant types everywhere for now.
